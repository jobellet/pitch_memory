<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Pitch Discrimination Experiment – Adaptive Staircase (Log-Sampling)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    /* Full-page layout, no scrolling */
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      font-family: sans-serif;
      overflow: hidden;
    }
    .screen {
      position: relative;
      width: 100%;
      height: 100%;
      display: none;
    }
    .centered-content {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      width: 100%;
      height: 100%;
      padding: 20px;
      box-sizing: border-box;
    }
    button {
      font-size: 1rem;
      margin: 10px;
      padding: 10px 20px;
      cursor: pointer;
    }
    /* ===== Trial Screen Layout ===== */
    #trialScreen {
      display: none;
      position: relative;
      width: 100%;
      height: 100%;
      background-color: #fff;
    }
    /* A small bar at the top to display "Trial n/10" (in real experiment) */
    #trialCounter {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 40px;
      line-height: 40px;
      background-color: #ddd;
      text-align: center;
      font-weight: bold;
      display: none;
    }
    /* Horizontal line at 50% of the screen height */
    #horizontalLine {
      position: absolute;
      left: 0;
      width: 100%;
      height: 2px;
      background-color: black;
      top: 50%; 
      margin: 0;
      padding: 0;
    }
    /* Top half => Higher (with arrow) */
    #higherArea {
      position: absolute;
      top: 40px;
      left: 0;
      width: 100%;
      height: calc(50% - 40px);
      background-color: gray;  /* Initially gray */
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 2rem;
      cursor: pointer;
    }
    /* Bottom half => Lower (with arrow) */
    #lowerArea {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 50%;
      background-color: gray;  /* Initially gray */
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 2rem;
      cursor: pointer;
    }
  </style>
</head>
<body>

<!-- =============== 1. Intro Screen =============== -->
<div id="introScreen" class="screen">
  <div class="centered-content">
    <h1>Pitch Discrimination Experiment</h1>
    <p>
      You will hear two tones in quick succession.<br>
      Decide if the <strong>second tone</strong> is higher (<strong>↑</strong>) or lower (<strong>↓</strong>) than the first.<br><br>
      - <strong>Keyboard</strong>: Up Arrow = Higher, Down Arrow = Lower<br>
      - <strong>Touch</strong>: Tap the top half for Higher, bottom half for Lower<br><br>
      First, you'll do <strong>test trials</strong> (with an easy large difference).<br>
      Once you get 5 correct, you'll start the <strong>real experiment</strong> in batches of 10 trials,<br>
      using an <strong>adaptive</strong> procedure that updates the difficulty range after each batch.<br>
      <strong>Note:</strong> You can only respond <em>after</em> the second tone has started playing.
    </p>
    <button id="startTestBtn">Start Test Trials</button>
    <br>
    <p>Or skip test trials by uploading a previous experiment data file:</p>
    <button id="uploadBtn">Upload Previous Data & Skip Test</button>
    <input type="file" id="fileInput" accept=".json" style="display:none;" />
  </div>
</div>

<!-- =============== 2. Trial Screen =============== -->
<div id="trialScreen" class="screen">
  <div id="trialCounter"></div>
  <div id="horizontalLine"></div>
  <div id="higherArea">HIGHER ↑</div>
  <div id="lowerArea">LOWER ↓</div>
</div>

<!-- =============== 3. Test Complete Screen =============== -->
<div id="testCompleteScreen" class="screen">
  <div class="centered-content">
    <h1>Test Complete!</h1>
    <p>
      You have reached 5 correct answers in the test trials.<br>
      Now the real experiment will begin using a log-spaced adaptive procedure.<br>
      After each batch of 10 trials, the difficulty range updates,<br>
      and new tone differences will be sampled uniformly in log space between the identified bounds.<br><br>
      Click or press <strong>Enter</strong> to continue.
    </p>
    <button id="startRealBtn">Continue</button>
  </div>
</div>

<!-- =============== 4. Batch End Screen (10 Trials) =============== -->
<div id="batchEndScreen" class="screen">
  <div class="centered-content">
    <h1>Batch Complete</h1>
    <p>
      You have finished 10 trials in this batch.<br>
      Press <strong>Enter</strong> (or click below) to continue,<br>
      or press <strong>Esc</strong> (or click below) to stop.
    </p>
    <button id="continueBtn">Continue (Enter)</button>
    <button id="stopBtn">Stop (Esc)</button>
  </div>
</div>

<!-- =============== 5. Final Screen =============== -->
<div id="finalScreen" class="screen">
  <div class="centered-content">
    <h1>Experiment Ended</h1>
    <p>Thank you for participating!</p>
    <button id="downloadBtn">Download Data</button>
  </div>
</div>

<script>
/* ===========================
   0. Global Parameters
=========================== */
let isTestMode = false;
const NEEDED_TEST_CORRECT = 5;
let testCorrectCount = 0;

const TRIALS_PER_BATCH = 10;
let batchNumber = 0;
let trialNumberInBatch = 0;

let audioContext;
const MIN_BASE_FREQ = 220;
const MAX_BASE_FREQ = 880;
const TONE_DURATION = 0.25;
const MIN_GAP_MS    = 250;
const MAX_GAP_MS    = 2000;

let baseFrequency;
let secondFrequency;
let isSecondHigher;
let firstSoundStartTime = 0;
let secondSoundStartTime = 0;

/* To ignore user responses until second tone onset */
let canRespond = false;

/* The data structure for all trials (test + real) */
let trialData = [];

/* Range boundaries for selecting next semitone (log-based selection).
   We'll clamp any picked difference to >= 0.001.
*/
let lowBound = 1;    // lower semitone limit
let highBound = 12;  // upper semitone limit

/* ===========================
   1. Utility: semitones->ratio
=========================== */
function semitonesToRatio(semitones) {
  // semitones could be positive or negative, but we only compute ratio from its magnitude 
  // if isSecondHigher is false, we invert it later by 1/ratio.
  return Math.pow(2, Math.abs(semitones) / 12);
}

/* Create or reuse AudioContext, play sine tone */
function playTone(freq, durationSec) {
  if (!audioContext) {
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
  }
  const osc = audioContext.createOscillator();
  osc.type = 'sine';
  osc.frequency.value = freq;

  const gain = audioContext.createGain();
  gain.gain.setValueAtTime(0, audioContext.currentTime);
  gain.gain.linearRampToValueAtTime(1, audioContext.currentTime + 0.01);
  gain.gain.setValueAtTime(1, audioContext.currentTime + durationSec - 0.01);
  gain.gain.linearRampToValueAtTime(0, audioContext.currentTime + durationSec);

  osc.connect(gain).connect(audioContext.destination);
  osc.start();
  osc.stop(audioContext.currentTime + durationSec);
}

/* ===========================
   2. Test Trials
=========================== */
function startTestTrials() {
  isTestMode = true;
  testCorrectCount = 0;
  runTestTrial();
}

function runTestTrial() {
  switchScreen('trialScreen');
  hideTrialCounter(true);

  // Display "HIGHER"/"LOWER" in gray, ignore responses until second tone onset
  prepareResponseAreasForNextTrial();

  baseFrequency = Math.random() * (MAX_BASE_FREQ - MIN_BASE_FREQ) + MIN_BASE_FREQ;
  isSecondHigher = (Math.random() < 0.5);

  // Use a large difference for easy test
  const testDiff = 12;
  let ratio = semitonesToRatio(testDiff);
  // If second is lower, invert ratio
  if (!isSecondHigher) ratio = 1 / ratio;

  let candidateFreq = baseFrequency * ratio;
  candidateFreq = Math.max(MIN_BASE_FREQ, Math.min(MAX_BASE_FREQ, candidateFreq));
  secondFrequency = candidateFreq;

  setTimeout(() => {
    firstSoundStartTime = performance.now();
    playTone(baseFrequency, TONE_DURATION);
    const gap = MIN_GAP_MS + Math.random() * (MAX_GAP_MS - MIN_GAP_MS);

    setTimeout(() => {
      secondSoundStartTime = performance.now();
      playTone(secondFrequency, TONE_DURATION);
      // Now user can respond
      enableResponseAreas();
    }, gap);
  }, 300);
}

/* ===========================
   3. Real Experiment in Batches
=========================== */
function startRealExperiment() {
  isTestMode = false;
  // If enough data from previous trials, recompute
  if (trialData.filter(t => !t.isTestMode).length > 5) {
    computeRange();
  } else {
    // Keep defaults
    lowBound = 1;
    highBound = 12;
  }
  batchNumber = 0;
  startNewBatch();
}

function startNewBatch() {
  batchNumber++;
  trialNumberInBatch = 0;
  runNextRealTrial();
}

function runNextRealTrial() {
  trialNumberInBatch++;
  switchScreen('trialScreen');
  hideTrialCounter(false);
  updateTrialCounter(trialNumberInBatch, TRIALS_PER_BATCH);

  // Display "HIGHER"/"LOWER" in gray, ignore responses until second tone
  prepareResponseAreasForNextTrial();

  baseFrequency = Math.random() * (MAX_BASE_FREQ - MIN_BASE_FREQ) + MIN_BASE_FREQ;
  isSecondHigher = (Math.random() < 0.5);

  // Pick a random semitone in log space between lowBound and highBound
  let randomSemitone;
  const absLow = Math.max(0.001, Math.abs(lowBound));
  const absHigh = Math.max(0.001, Math.abs(highBound));

  if (absLow < absHigh) {
    const logLow = Math.log10(absLow);
    const logHigh = Math.log10(absHigh);
    if (logHigh > logLow) {
      const randomLog = logLow + Math.random() * (logHigh - logLow);
      randomSemitone = Math.pow(10, randomLog);
    } else {
      // fallback if logs are flipped or identical
      randomSemitone = (absLow + absHigh) / 2;
    }
  } else {
    // fallback if bounds are invalid or insufficient data
    randomSemitone = (absLow + absHigh) / 2;
  }

  // clamp to 0.001 min
  randomSemitone = Math.max(0.001, randomSemitone);

  // Convert semitones -> ratio, then invert if second is lower
  let ratio = semitonesToRatio(randomSemitone);
  if (!isSecondHigher) ratio = 1 / ratio;

  secondFrequency = baseFrequency * ratio;
  secondFrequency = Math.max(MIN_BASE_FREQ, Math.min(MAX_BASE_FREQ, secondFrequency));

  setTimeout(() => {
    firstSoundStartTime = performance.now();
    playTone(baseFrequency, TONE_DURATION);
    const gap = MIN_GAP_MS + Math.random() * (MAX_GAP_MS - MIN_GAP_MS);
    setTimeout(() => {
      secondSoundStartTime = performance.now();
      playTone(secondFrequency, TONE_DURATION);
      // Now user can respond
      enableResponseAreas();
    }, gap);
  }, 300);
}

/* ===========================
   4. Handle Response and Batch Update
=========================== */
function handleResponse(userSaysHigher) {
  if (!canRespond) {
    // Ignore response if user tries to answer too early
    return;
  }

  const now = performance.now();
  const reactionTimeMs = now - secondSoundStartTime;
  const correct = (userSaysHigher === isSecondHigher);
  const gapDurationMs = secondSoundStartTime - firstSoundStartTime;

  // The actual semitone difference used is the absolute difference 
  // between secondFrequency and baseFrequency in semitones:
  const ratio = secondFrequency / baseFrequency;
  const usedSemitone = 12 * (Math.log(ratio) / Math.log(2));

  trialData.push({
    timestamp: new Date().toISOString(),
    isTestMode,
    batchNumber: isTestMode ? 0 : batchNumber,
    trialInBatch: isTestMode ? 0 : trialNumberInBatch,
    firstPitchHz: baseFrequency,
    secondPitchHz: secondFrequency,
    gapDurationMs: gapDurationMs.toFixed(2),
    // We store the absolute value so it's consistent with the log sampling approach
    relativeDiffSemitones: Math.max(0.001, Math.abs(usedSemitone)),
    userResponse: userSaysHigher ? "higher" : "lower",
    correctness: correct,
    reactionTimeMs: reactionTimeMs.toFixed(2)
  });

  if (isTestMode) {
    if (correct) {
      testCorrectCount++;
      alert(`Correct! (${testCorrectCount}/${NEEDED_TEST_CORRECT})`);
    } else {
      alert(`Wrong! (${testCorrectCount}/${NEEDED_TEST_CORRECT} so far)`);
    }
    if (testCorrectCount >= NEEDED_TEST_CORRECT) {
      switchScreen('testCompleteScreen');
    } else {
      runTestTrial();
    }
  } else {
    if (trialNumberInBatch >= TRIALS_PER_BATCH) {
      // After each batch, update the range
      computeRange();
      switchScreen('batchEndScreen');
    } else {
      runNextRealTrial();
    }
  }
}

/* ===========================
   4B. Helpers for disabling and enabling response
=========================== */
function prepareResponseAreasForNextTrial() {
  canRespond = false;
  const higherArea = document.getElementById('higherArea');
  const lowerArea = document.getElementById('lowerArea');
  higherArea.style.backgroundColor = 'gray';
  lowerArea.style.backgroundColor = 'gray';
}

function enableResponseAreas() {
  canRespond = true;
  const higherArea = document.getElementById('higherArea');
  const lowerArea = document.getElementById('lowerArea');
  // Original color scheme:
  higherArea.style.backgroundColor = '#eef';
  lowerArea.style.backgroundColor = '#fee';
}

/* ===========================
   5. Compute Range for Next Trials
=========================== */
function computeRange() {
  const data = trialData.filter(trial => !trial.isTestMode);
  if(data.length < 5) {
    // Not enough data: use default range
    lowBound = 1;
    highBound = 12;
    return;
  }
  
  // Get sorted unique semitone differences from the data (absolute)
  let values = [...new Set(data.map(t => Math.abs(t.relativeDiffSemitones)))];
  values = values.filter(v => v >= 0.001); // ensure >= 0.001
  values.sort((a,b) => a - b);

  if (values.length < 2) {
    // Edge case: still not enough unique values
    lowBound = 1;
    highBound = 12;
    return;
  }

  let potentialLow = null;
  let potentialHigh = null;
  
  // For each unique semitone "v":
  //   meanA = mean accuracy for all trials with semitones < v
  //   meanB = mean accuracy for all trials with semitones >= v
  // We want to find v s.t. meanA < 0.7, and v' s.t. meanB > 0.8
  // so we define a range [v, v'].
  for (let v of values) {
    const below = data.filter(t => Math.abs(t.relativeDiffSemitones) < v);
    const meanA = below.length 
      ? below.reduce((sum, t) => sum + (t.correctness ? 1 : 0), 0) / below.length 
      : 0;
    if (meanA < 0.7) {
      potentialLow = v;
      break;
    }
  }

  for (let i = values.length - 1; i >= 0; i--) {
    const v = values[i];
    const above = data.filter(t => Math.abs(t.relativeDiffSemitones) >= v);
    const meanB = above.length
      ? above.reduce((sum, t) => sum + (t.correctness ? 1 : 0), 0) / above.length
      : 0;
    if (meanB > 0.8) {
      potentialHigh = v;
      break;
    }
  }

  // Update global lowBound, highBound
  if(potentialLow !== null && potentialHigh !== null && potentialLow < potentialHigh) {
    lowBound = Math.max(0.001, potentialLow);
    highBound = Math.max(lowBound + 0.0001, potentialHigh); // ensure highBound >= lowBound
  } else {
    lowBound = 1;
    highBound = 12;
  }
}

/* ===========================
   6. Trial Counter Utility
=========================== */
function hideTrialCounter(shouldHide) {
  const tc = document.getElementById('trialCounter');
  tc.style.display = shouldHide ? "none" : "block";
}
function updateTrialCounter(current, total) {
  const tc = document.getElementById('trialCounter');
  tc.textContent = `Trial ${current} / ${total}`;
}

/* ===========================
   7. Screen Switching
=========================== */
function switchScreen(screenId) {
  const allScreens = [
    'introScreen',
    'trialScreen',
    'testCompleteScreen',
    'batchEndScreen',
    'finalScreen'
  ];
  allScreens.forEach(id => {
    document.getElementById(id).style.display = (id === screenId) ? 'block' : 'none';
  });
}

/* ===========================
   8. Download Data
=========================== */
function downloadData() {
  const dataStr = JSON.stringify(trialData, null, 2);
  const blob = new Blob([dataStr], {type: "application/json"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'experiment_data.json';
  a.click();
  URL.revokeObjectURL(url);
}

/* ===========================
   9. File Upload Handler
=========================== */
document.getElementById('uploadBtn').addEventListener('click', () => {
  document.getElementById('fileInput').click();
});

document.getElementById('fileInput').addEventListener('change', (event) => {
  const file = event.target.files[0];
  if (!file) return;
  
  const reader = new FileReader();
  reader.onload = function(e) {
    try {
      const loadedData = JSON.parse(e.target.result);
      if (Array.isArray(loadedData)) {
        trialData = loadedData.concat(trialData);
      } else {
        alert('Invalid data format in JSON file.');
        return;
      }
      startRealExperiment();
    } catch (err) {
      alert('Error parsing JSON file: ' + err);
    }
  };
  reader.readAsText(file);
});

/* ===========================
   10. Event Listeners
=========================== */
// Intro
document.getElementById('startTestBtn').addEventListener('click', () => {
  trialData = [];
  startTestTrials();
});

// Test Complete
document.getElementById('startRealBtn').addEventListener('click', () => {
  startRealExperiment();
});

// Batch End
document.getElementById('continueBtn').addEventListener('click', () => {
  startNewBatch();
});
document.getElementById('stopBtn').addEventListener('click', () => {
  switchScreen('finalScreen');
});

// Final
document.getElementById('downloadBtn').addEventListener('click', downloadData);

// Trial Screen: top => higher, bottom => lower
document.getElementById('higherArea').addEventListener('click', () => {
  handleResponse(true);
});
document.getElementById('lowerArea').addEventListener('click', () => {
  handleResponse(false);
});

// Keyboard shortcuts
document.addEventListener('keydown', (e) => {
  const trialVisible = (document.getElementById('trialScreen').style.display === 'block');
  const batchEndVisible = (document.getElementById('batchEndScreen').style.display === 'block');
  const testCompleteVisible = (document.getElementById('testCompleteScreen').style.display === 'block');

  if(trialVisible) {
    if(e.key === 'ArrowUp') {
      e.preventDefault();
      handleResponse(true);
    } else if(e.key === 'ArrowDown') {
      e.preventDefault();
      handleResponse(false);
    }
  } 
  else if(batchEndVisible) {
    if(e.key === 'Enter') {
      e.preventDefault();
      startNewBatch();
    } else if(e.key === 'Escape') {
      e.preventDefault();
      switchScreen('finalScreen');
    }
  }
  else if(testCompleteVisible) {
    if(e.key === 'Enter') {
      e.preventDefault();
      startRealExperiment();
    }
  }
});

// Show the Intro screen initially
switchScreen('introScreen');
</script>
</body>
</html>
