<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Pitch Discrimination Experiment – Logistic Fit at 50 Trials</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    /* Full-page layout, no scrolling */
    html, body {
      margin: 0; padding: 0;
      width: 100%; height: 100%;
      font-family: sans-serif;
      overflow: hidden;
    }
    .screen {
      position: relative;
      width: 100%; height: 100%;
      display: none;
    }
    .centered-content {
      display: flex; flex-direction: column;
      align-items: center; justify-content: center;
      text-align: center;
      width: 100%; height: 100%;
      padding: 20px; box-sizing: border-box;
    }
    button {
      font-size: 1rem; margin: 10px; padding: 10px 20px;
      cursor: pointer;
    }

    /* ===== Trial Screen Layout ===== */
    #trialScreen {
      position: relative;
      width: 100%; height: 100%;
      background-color: #fff;
      display: none;
    }
    #trialCounter {
      position: absolute; top: 0; left: 0;
      width: 100%; height: 40px; line-height: 40px;
      background-color: #ddd; text-align: center;
      font-weight: bold; display: none;
    }
    #horizontalLine {
      position: absolute; left: 0; width: 100%; height: 2px;
      background-color: black; top: 50%; margin: 0; padding: 0;
    }
    #higherArea, #lowerArea {
      width: 100%;
      display: flex; align-items: center; justify-content: center;
      font-size: 2rem; cursor: pointer;
    }
    #higherArea {
      position: absolute; top: 40px; left: 0;
      height: calc(50% - 40px);
      background-color: gray; /* initially disabled */
    }
    #lowerArea {
      position: absolute; bottom: 0; left: 0;
      height: 50%;
      background-color: gray; /* initially disabled */
    }
  </style>
</head>
<body>

<!-- =============== 1. Intro Screen =============== -->
<div id="introScreen" class="screen">
  <div class="centered-content">
    <h1>Pitch Discrimination Experiment</h1>
    <p>
      You will hear two tones in quick succession.<br>
      Decide if the <strong>second tone</strong> is higher (<strong>↑</strong>) 
      or lower (<strong>↓</strong>) than the first.<br><br>
      - <strong>Keyboard</strong>: Up Arrow = Higher, Down Arrow = Lower<br>
      - <strong>Touch</strong>: Tap the top half for Higher, bottom half for Lower<br><br>
      For the first 50 trials, the semitone difference is randomly chosen between 0.01 and 1 (uniform in log10).<br>
      After 50 trials, a logistic curve is fit, and only semitones in the <em>70–80% accuracy</em> region are tested.<br>
      This region is recalculated after every 10 trials.
    </p>
    <button id="startBtn">Start Experiment</button>
    <br>
    <p>Or upload a previous dataset (JSON):</p>
    <button id="uploadBtn">Upload Data</button>
    <input type="file" id="fileInput" accept=".json" style="display:none;" />
  </div>
</div>

<!-- =============== 2. Trial Screen =============== -->
<div id="trialScreen" class="screen">
  <div id="trialCounter"></div>
  <div id="horizontalLine"></div>
  <div id="higherArea">HIGHER ↑</div>
  <div id="lowerArea">LOWER ↓</div>
</div>

<!-- =============== 3. Batch Complete Screen =============== -->
<div id="batchEndScreen" class="screen">
  <div class="centered-content">
    <h1>Batch Complete</h1>
    <p>
      You have finished 10 trials in this batch.<br>
      Press <strong>Enter</strong> (or click below) to continue,<br>
      or press <strong>Esc</strong> (or click below) to stop.
    </p>
    <button id="continueBtn">Continue (Enter)</button>
    <button id="stopBtn">Stop (Esc)</button>
  </div>
</div>

<!-- =============== 4. Final Screen =============== -->
<div id="finalScreen" class="screen">
  <div class="centered-content">
    <h1>Experiment Ended</h1>
    <p>Thank you for participating!</p>
    <button id="downloadBtn">Download Data</button>
  </div>
</div>

<script>
/* ===========================
   0. Global Parameters
=========================== */
let audioContext;
const TONE_DURATION = 0.25;
const MIN_BASE_FREQ = 220;
const MAX_BASE_FREQ = 880;
const MIN_GAP_MS = 250;
const MAX_GAP_MS = 2000;

// For the first 50 trials => random .01–1 semitones, log10 sampling
const FREE_EXPLORATION_COUNT = 50;

// After 50 trials => logistic fit each time we complete 10 trials
const TRIALS_PER_BATCH = 10;

let trialNumber = 0;     // counts how many trials total
let trialNumberInBatch = 0;
let batchNumber = 0;

let baseFrequency = 440;
let secondFrequency = 660;
let isSecondHigher = true;
let firstSoundStartTime = 0;
let secondSoundStartTime = 0;
let canRespond = false;

// Data
let trialData = [];

// Our logistic curve parameters, updated after 50 trials and each 10-trial batch
let alphaFit = -1;   // initial guess
let betaFit  = 0.5;  // initial guess

// Range of semitones used after fitting. We'll find semitones for logistic in [0.7, 0.8].
let lowSemitoneRange = 0.01;
let highSemitoneRange = 1.0;

/* ===========================
   1. Setup
=========================== */
document.getElementById('startBtn').addEventListener('click', () => {
  trialData = [];
  trialNumber = 0;
  trialNumberInBatch = 0;
  batchNumber = 0;
  startTrial();
});

document.getElementById('uploadBtn').addEventListener('click', () => {
  document.getElementById('fileInput').click();
});
document.getElementById('fileInput').addEventListener('change', (event) => {
  const file = event.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = function(e) {
    try {
      const loadedData = JSON.parse(e.target.result);
      if (Array.isArray(loadedData)) {
        trialData = loadedData.concat(trialData);
      } else {
        alert('Invalid JSON format.');
        return;
      }
      // Start from the next trial
      trialNumber = trialData.length;
      trialNumberInBatch = trialNumber % TRIALS_PER_BATCH;
      batchNumber = Math.floor(trialNumber / TRIALS_PER_BATCH);
      startTrial();
    } catch (err) {
      alert('Error parsing JSON: ' + err);
    }
  };
  reader.readAsText(file);
});

document.getElementById('continueBtn').addEventListener('click', () => {
  startNewBatch();
});
document.getElementById('stopBtn').addEventListener('click', () => {
  switchScreen('finalScreen');
});
document.getElementById('downloadBtn').addEventListener('click', downloadData);

document.getElementById('higherArea').addEventListener('click', () => handleResponse(true));
document.getElementById('lowerArea').addEventListener('click', () => handleResponse(false));

document.addEventListener('keydown', (e) => {
  const trialVisible = (document.getElementById('trialScreen').style.display === 'block');
  const batchEndVisible = (document.getElementById('batchEndScreen').style.display === 'block');

  if(trialVisible) {
    if(e.key === 'ArrowUp') {
      e.preventDefault();
      handleResponse(true);
    } else if(e.key === 'ArrowDown') {
      e.preventDefault();
      handleResponse(false);
    }
  }
  else if(batchEndVisible) {
    if(e.key === 'Enter') {
      e.preventDefault();
      startNewBatch();
    } else if(e.key === 'Escape') {
      e.preventDefault();
      switchScreen('finalScreen');
    }
  }
});

/* ===========================
   2. Trials
=========================== */
function startTrial() {
  switchScreen('trialScreen');
  updateTrialCounter(trialNumberInBatch+1, TRIALS_PER_BATCH);

  // Gray out response until second tone
  setResponseActive(false);

  // 1) Choose base freq
  baseFrequency = Math.random() * (MAX_BASE_FREQ - MIN_BASE_FREQ) + MIN_BASE_FREQ;

  // 2) is second tone higher or lower
  isSecondHigher = (Math.random() < 0.5);

  // 3) pick semitone difference
  let absSemitone;
  if(trialNumber < FREE_EXPLORATION_COUNT) {
    // first 50 trials => uniform in log10 from .01 to 1
    absSemitone = pickRandomInLogSpace(0.01, 1);
  } else {
    // after 50 trials => logistic fit is done => sample in [lowSemitoneRange, highSemitoneRange] in log space
    absSemitone = pickRandomInLogSpace(lowSemitoneRange, highSemitoneRange);
  }

  // 4) compute ratio
  let ratio = Math.pow(2, absSemitone / 12);
  if (!isSecondHigher) ratio = 1 / ratio;

  secondFrequency = clampFreq(baseFrequency * ratio);

  // 5) Play
  setTimeout(() => {
    firstSoundStartTime = performance.now();
    playTone(baseFrequency, TONE_DURATION);

    const gap = MIN_GAP_MS + Math.random() * (MAX_GAP_MS - MIN_GAP_MS);
    setTimeout(() => {
      secondSoundStartTime = performance.now();
      playTone(secondFrequency, TONE_DURATION);
      setResponseActive(true);
    }, gap);
  }, 300);
}

/* Handle response */
function handleResponse(userSaysHigher) {
  if (!canRespond) return; // ignore if responded too early

  const now = performance.now();
  const correct = (userSaysHigher === isSecondHigher);
  const gapDurationMs = (secondSoundStartTime - firstSoundStartTime).toFixed(2);
  const reactionTimeMs = (now - secondSoundStartTime).toFixed(2);

  // compute actual used semitone (abs)
  const ratio = secondFrequency / baseFrequency;
  const usedSemitone = 12 * (Math.log(ratio) / Math.log(2));
  const absSem = Math.max(0.00001, Math.abs(usedSemitone));

  trialData.push({
    timestamp: new Date().toISOString(),
    trialIndex: trialNumber + 1,
    batchNumber: batchNumber,
    trialInBatch: (trialNumberInBatch + 1),
    firstPitchHz: baseFrequency,
    secondPitchHz: secondFrequency,
    gapDurationMs: gapDurationMs,
    relativeDiffSemitones: absSem,
    userResponse: userSaysHigher ? "higher" : "lower",
    correctness: correct,
    reactionTimeMs: reactionTimeMs
  });

  // update counters
  trialNumber++;
  trialNumberInBatch++;
  
  if(trialNumberInBatch >= TRIALS_PER_BATCH) {
    // end of a batch => maybe re-fit logistic if we are beyond 50 trials
    if(trialNumber >= FREE_EXPLORATION_COUNT) {
      fitLogisticAndUpdateRange();
    }
    switchScreen('batchEndScreen');
  } else {
    // continue
    startTrial();
  }
}

/* Start next batch after finishing 10 trials. */
function startNewBatch() {
  batchNumber++;
  trialNumberInBatch = 0;
  startTrial();
}

/* ===========================
   3. Logistic Fit & Range 
=========================== */
/**
 * We fit logistic: P(x) = 0.5 + 0.5 / [1 + exp(-(x - alpha)/beta)]
 * x = log10(semitone).
 * We'll do a naive grid-search in alpha in [-3..0], beta in [0.05..1], stepping some small increments.
 * Minimizing SSE or cross-entropy. We'll do SSE for simplicity.
 */
function fitLogisticAndUpdateRange() {
  const data = trialData; // all trials so far
  if(data.length < 10) return; // not enough data

  // Extract x=log10(semitone), y=correctness
  const xs = [];
  const ys = [];
  for(let d of data) {
    const sem = d.relativeDiffSemitones;
    if(sem > 0) {
      xs.push(Math.log10(sem));
      ys.push(d.correctness ? 1 : 0);
    }
  }
  if(xs.length < 10) return; // still no enough valid points

  // Naive search
  let bestAlpha = -1;
  let bestBeta = 0.5;
  let bestSSE = 1e9;

  // alpha: from -3 to 0 in steps of 0.05
  // beta : from 0.05 to 1.0 in steps of 0.05
  for(let alpha = -3; alpha <= 0; alpha += 0.05) {
    for(let beta = 0.05; beta <= 1.0; beta += 0.05) {
      let sse = 0;
      for(let i=0; i<xs.length; i++){
        const pred = logistic(xs[i], alpha, beta);
        const diff = (pred - ys[i]);
        sse += diff * diff;
      }
      if(sse < bestSSE) {
        bestSSE = sse;
        bestAlpha = alpha;
        bestBeta = beta;
      }
    }
  }

  alphaFit = bestAlpha;
  betaFit = bestBeta;

  // Now find semitone range for which logistic in [0.7..0.8].
  // We'll search in [log10(0.001)..log10(2.0)] or something, because we know max semitone is 2?
  // Actually, user said up to 1 semitone, but let's assume maybe up to ~2 semitones for safety
  let leftBound = 0.01;
  let rightBound = 1.0;

  // We'll sample many points in [0.001..2.0], see which region yields logistic in [0.7..0.8].
  // Then pick min, max semitone from that region.
  let candidateX = [];
  for(let logx=-3; logx<=0.3; logx+=0.01) {
    candidateX.push(logx);
  }

  let validXs = candidateX.filter(xx => {
    const p = logistic(xx, alphaFit, betaFit);
    return (p >= 0.7 && p <= 0.8);
  });

  // If we have any valid points, pick min & max of that set => in semitone domain
  if(validXs.length > 0) {
    leftBound = Math.pow(10, Math.min(...validXs));
    rightBound = Math.pow(10, Math.max(...validXs));
  } else {
    // fallback
    leftBound = 0.01;
    rightBound = 1.0;
  }

  lowSemitoneRange = clampRange(leftBound);
  highSemitoneRange = clampRange(rightBound);
}

function logistic(x, alpha, beta) {
  // bounded between 0.5 and 1
  return 0.5 + 0.5 / (1 + Math.exp(-(x - alpha)/beta));
}
function clampRange(v) {
  return Math.min(2.0, Math.max(0.01, v));  // clamp range to [0.01..2]
}

/* ===========================
   4. Utility
=========================== */
function pickRandomInLogSpace(minVal, maxVal) {
  const logMin = Math.log10(minVal);
  const logMax = Math.log10(maxVal);
  const r = Math.random();
  const randLog = logMin + r*(logMax - logMin);
  return Math.pow(10, randLog);
}

function clampFreq(freq) {
  return Math.max(MIN_BASE_FREQ, Math.min(MAX_BASE_FREQ, freq));
}

function setResponseActive(state) {
  canRespond = state;
  const higherArea = document.getElementById('higherArea');
  const lowerArea = document.getElementById('lowerArea');
  if(state) {
    higherArea.style.backgroundColor = '#eef';
    lowerArea.style.backgroundColor = '#fee';
  } else {
    higherArea.style.backgroundColor = 'gray';
    lowerArea.style.backgroundColor = 'gray';
  }
}

/* Show/hide screens */
function switchScreen(screenId) {
  const allScreens = ['introScreen', 'trialScreen','batchEndScreen','finalScreen'];
  allScreens.forEach(id => {
    document.getElementById(id).style.display = (id === screenId) ? 'block' : 'none';
  });
}
function updateTrialCounter(current, total) {
  const tc = document.getElementById('trialCounter');
  tc.style.display = "block";
  tc.textContent = `Trial ${current} / ${total}`;
}

/* Audio: play tone */
function playTone(freq, durationSec) {
  if(!audioContext) {
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
  }
  const osc = audioContext.createOscillator();
  osc.type = 'sine';
  osc.frequency.value = freq;

  const gain = audioContext.createGain();
  gain.gain.setValueAtTime(0, audioContext.currentTime);
  gain.gain.linearRampToValueAtTime(1, audioContext.currentTime + 0.01);
  gain.gain.setValueAtTime(1, audioContext.currentTime + durationSec - 0.01);
  gain.gain.linearRampToValueAtTime(0, audioContext.currentTime + durationSec);

  osc.connect(gain).connect(audioContext.destination);
  osc.start();
  osc.stop(audioContext.currentTime + durationSec);
}

/* ===========================
   5. Download Data
=========================== */
function downloadData() {
  const dataStr = JSON.stringify(trialData, null, 2);
  const blob = new Blob([dataStr], {type: "application/json"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'experiment_data.json';
  a.click();
  URL.revokeObjectURL(url);
}

/* Show intro */
switchScreen('introScreen');
</script>
</body>
</html>